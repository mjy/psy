<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Psy::Matrix::Matrix</title>
<link rel="stylesheet" href="../../../..//Active.css" type="text/css" />
<link rev="made" href="mailto:" />
</head>

<body>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;Psy::Matrix::Matrix</span></strong></big>
</td></tr>
</table>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#version">VERSION</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#object">OBJECT</a></li>
	<ul>

		<li><a href="#_load">_load</a></li>
		<li><a href="#_load_phase_simulate">_load_PHASE_simulate</a></li>
		<li><a href="#ter">ter</a></li>
		<li><a href="#blk">blk</a></li>
		<li><a href="#cell">cell</a></li>
		<li><a href="#rawcell">rawCell</a></li>
		<li><a href="#yx">yx</a></li>
		<li><a href="#rawrowdata">rawRowData</a></li>
		<li><a href="#column">column</a></li>
		<li><a href="#rowasarray">rowAsArray</a></li>
		<li><a href="#blockdata">blockData</a></li>
		<li><a href="#slicedata">sliceData</a></li>
		<li><a href="#colinblk">colInBlk</a></li>
		<li><a href="#loopblocks">loopBlocks</a></li>
		<li><a href="#plan">plan</a></li>
		<li><a href="#fragmenthash">fragmentHash</a></li>
		<li><a href="#lastblockindex">lastBlockIndex</a></li>
		<li><a href="#insertblock">insertBlock</a></li>
		<li><a href="#terlabel2index">terLabel2Index</a></li>
		<li><a href="#totalchars">totalChars</a></li>
		<li><a href="#loopters">loopTers</a></li>
		<li><a href="#lengthlongestter">lengthLongestTer</a></li>
		<li><a href="#_calcblockpositions">_calcBlockPositions</a></li>
		<li><a href="#_terminaladd">_terminalAdd</a></li>
	</ul>

	<li><a href="#accessors">Accessors</a></li>
	<ul>

		<li><a href="#label">label</a></li>
		<li><a href="#totalblocks">totalBlocks</a></li>
		<li><a href="#origslice">origSlice</a></li>
		<li><a href="#origstructure">origStructure</a></li>
		<li><a href="#originterleave">origInterleave</a></li>
		<li><a href="#alignblock">alignBlock</a></li>
		<li><a href="#alignsliceblocks">alignSliceBlocks</a></li>
		<li><a href="#blk2fastmatrix">blk2Fastmatrix </a></li>
		<li><a href="#fastmatrix2blk">fastmatrix2Blk </a></li>
		<li><a href="#origslicehash">origSliceHash</a></li>
	</ul>

</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Psy::Psy</p>
<p>
<a href="#__index__"><small>__top</small></a>
</p>
<hr />
<h1><a name="version">VERSION</a></h1>
<p>Version 0.01</p>
<p>
<a href="#__index__"><small>__top</small></a>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p><table cellspacing="0" cellpadding="0"><tr><td>my $foo = matrix-&gt;new(
<tr><td><td>'-filename' =&gt; 'Evanioidea.0.04.Nex',
<tr><td><td>'-path' =&gt; '../../data/evan/',
<tr><td><td>'-number_terminals' =&gt; '59'  # n-1
<tr><td><td>);</table></p>
<p>#print ``\n'';
#print Dumper($foo);
#print ``\n'';
#print $foo-&gt;{blocks}-&gt;version();</p>
<p>use Psy::Matrix;</p>
<p>my $foo = matrix-&gt;new();
    ...</p>
<p>
<a href="#__index__"><small>__top</small></a>
</p>
<hr />
<h1><a name="object">OBJECT</a></h1>
<p>
</p>
<h2><a name="_load">_load</a></h2>
<p>Internal.  Used to load Psy/jRNA formats and Stockholm format.</p>
<p>Needs an over-ride ultimately, likely to set to a single filetype.</p>
<p>
</p>
<h2><a name="_load_phase_simulate">_load_PHASE_simulate</a></h2>
<p>NOT WORKING!</p>
<p>Loads a file generated by PHASE 2.0(beta)'s simulate package.</p>
<p>At this point it handles only a MIXED model, where the second model is RNA with a repeating () structure (the first parition is essentially ignored.</p>
<p>You must include a -struct_size of 2 or larger.  For example if your simulate structure is () then struct_size = 2. (()) = 4 etc.</p>
<p>
</p>
<h2><a name="ter">ter</a></h2>
<p>Returns the terminal _object_ for the passed index.</p>
<pre>
        Smx-&gt;ter(2);</pre>
<p>
</p>
<h2><a name="blk">blk</a></h2>
<p><table cellspacing="0" cellpadding="0"><tr><td>Returns the block meta-data _object_ (not index) for a given block ## COMPLETE to full accession? (low priority).
<tr><td><td>Smx-&gt;blk(2);</table></p>
<p>
</p>
<h2><a name="cell">cell</a></h2>
<p>Returns the sequence data for a -ter, -col pair.</p>
<pre>
        Smx-&gt;cell('-ter' =&gt; 1, '-col' =&gt; 2);</pre>
<p>
</p>
<h2><a name="rawcell">rawCell</a></h2>
<p>Returns sequence data minus the regex -gapchar for a -ter, -col pair.</p>
<pre>
        Smx-&gt;cell('-ter' =&gt; 1, '-col' =&gt; 2, '-gapchar' =&gt; '-'); OR
        Smx-&gt;cell('-ter' =&gt; 1, '-col' =&gt; 2, '-gapchar' =&gt; '[ACT]');</pre>
<p>
</p>
<h2><a name="yx">yx</a></h2>
<p>Returns sequence data in a yx accessor for matrix, only returns values!</p>
<pre>
        Smx-&gt;yx(1,2);</pre>
<p>
</p>
<h2><a name="rawrowdata">rawRowData</a></h2>
<p>As in rawCell, but across a given row- overwritten by a -slice.</p>
<pre>
        Smx-&gt;rawRowData(
                '-gapchar' =&gt; '-',
                '-u2t' =&gt; 0,
                '-slice' =&gt; $my_slice,
                '-legal_alphabet' =&gt; $alphabet
        );</pre>
<p>
</p>
<h2><a name="column">column</a></h2>
<p>Returns a column vector (string).</p>
<p>Requires either -col OR -pos and -blk.</p>
<p>If -blk is passed then -col is reference to position in block (0 is first position).</p>
<p><table cellspacing="0" cellpadding="0"><tr><td>Usage: 
<tr><td><td>Smx-&gt;column(
<tr><td><td>'-blk' =&gt; 0,
<tr><td><td>'-pos' =&gt; 1,
<tr><td><td>);
<tr><td><td>OR
<tr><td><td>Smx-&gt;column(
<tr><td><td>'-col' =&gt; 32
<tr><td><td>);</table></p>
<p>See also columns package.  No bracketed columns can be returned.</p>
<p>
</p>
<h2><a name="rowasarray">rowAsArray</a></h2>
<p>-returns the sequence data for a given taxa for a given -slice as an array of blocks of length -max_seq_length
-strips the -gapchar regex if provided prior to calculating the length
-cleans the data if -alphabet and -clean set</p>
<p>
</p>
<h2><a name="blockdata">blockData</a></h2>
<p>Returns an array of all blocks of data for a given -blk, takes -slice too.</p>
<pre>
        Smx-&gt;blockData(
                '-blk' =&gt; 0,
                '-slice' =&gt; $my_slice,
        );</pre>
<p>
</p>
<h2><a name="slicedata">sliceData</a></h2>
<p>Returns an array (DON'T DEPEND ON ORDER) containing all data in the passed slice, if no slice is passed the original slice (all data) is returned.</p>
<pre>
        Smx-&gt;sliceData(
                '-slice' =&gt; $my_slice,
        );</pre>
<p>
</p>
<h2><a name="colinblk">colInBlk</a></h2>
<p>Returns the block index to which -col (the column) can be found within.</p>
<p>Two modes: -mode =&gt; includebracketed | excludebracketed, defaults to later.</p>
<p>
</p>
<h2><a name="loopblocks">loopBlocks</a></h2>
<p>Returns an ordered array of block indices for the given slice of particular type, similar functions availible for slice objects.</p>
<p>Hmm.  Likely need to merge with slice object.</p>
<p><table cellspacing="0" cellpadding="0"><tr><td>Legal values for 
<tr><td><td>-mode =&gt; &lt; unbracketed | bracketed | [all] | fiveprime &gt;</table></p>
<p>
</p>
<h2><a name="plan">plan</a></h2>
<p><table cellspacing="0" cellpadding="0"><tr><td>Returns a basic 'plan', which is essentially a directive to fuse or not fuse paritions.
<tr><td><td>'-mode' =&gt; &lt; [basic] (recoded bracketed blocks) | all (recode all blocks) | all_fused (returns 1 big partition = the full slice) &gt;
<tr><td><td>'-slice' =&gt; '$self-&gt;origSlice'
</table></p>
<pre>

=cut</pre>
<p><table cellspacing="0" cellpadding="0"><tr><td>sub plan {
<tr><td><td>my $self = shift;
<tr><td><td>my %raw_params = @_;
<tr><td><td>my %default_params = ('-mode' =&gt; 'basic', '-slice' =&gt; $self-&gt;origSlice);
<tr><td><td>my %params = (%default_params, %raw_params);</table></p>
<pre>
        my $p;
                
        if ( $params{'-mode'} eq 'all_fused') {
                $p-&gt;{1}-&gt;{blks} = ([$params{'-slice'}-&gt;loop('Blocks')]);
                $p-&gt;{1}-&gt;{kword} = 1;
                $p-&gt;{1}-&gt;{type} = 'trans'
        }</pre>
<pre>
        else {  
                for my $blk ($params{'-slice'}-&gt;loop('Blocks')) {</pre>
<pre>
                        if ($self-&gt;blk($blk)-&gt;bracketed == 1) {
                                $p-&gt;{$blk}-&gt;{blks} = ([$blk]);
                                $p-&gt;{$blk}-&gt;{kword} = 1; 
                                $p-&gt;{$blk}-&gt;{type} = 'trans' # its always translated
                        }
                        else {
                                if ($params{'-mode'} eq 'all') {
                                        $p-&gt;{$blk}-&gt;{blks} = ([$blk]);
                                        $p-&gt;{$blk}-&gt;{kword} = 1;
                                        $p-&gt;{$blk}-&gt;{type} = 'trans'
                                }
                                else {
                                        $p-&gt;{$blk}-&gt;{blks} = ([$blk]);
                                        $p-&gt;{$blk}-&gt;{kword} = 0; 
                                        $p-&gt;{$blk}-&gt;{type} = 'orig';
                                }                       
                        }
                }</pre>
<pre>
        }       
        return $p;
}</pre>
<p>
</p>
<h2><a name="fragmenthash">fragmentHash</a></h2>
<pre>

Returns a hash of unique fragments, and their total.</pre>
<p>
</p>
<h2><a name="lastblockindex">lastBlockIndex</a></h2>
<p>Returns the index of the last block.</p>
<p>
</p>
<h2><a name="insertblock">insertBlock</a></h2>
<p>Not tested/finished.</p>
<p>
</p>
<h2><a name="terlabel2index">terLabel2Index</a></h2>
<p>Returns the index of a given terminal -label</p>
<p>
</p>
<h2><a name="totalchars">totalChars</a></h2>
<p><table cellspacing="0" cellpadding="0"><tr><td>Returns the total number of characters for a given slice (defaults to whole matrix) for the given -slicemode
<tr><td><td>$mx-&gt;totalChars(
<tr><td><td>'-slicecharmode' =&gt; 'all'
<tr><td><td>);</table></p>
<p><table cellspacing="0" cellpadding="0"><tr><td>Options:
<tr><td><td>'-slicecharmode' =&gt; &lt; all | [unbracketed] | bracketed &gt;</table></p>
<p>
</p>
<h2><a name="loopters">loopTers</a></h2>
<p>Returns a sorted array of _indicies_ to the taxa in the matrix (no slice override)</p>
<p>
</p>
<h2><a name="lengthlongestter">lengthLongestTer</a></h2>
<p>Returns the length of the longest taxon name in a slice</p>
<p>
</p>
<h2><a name="_calcblockpositions">_calcBlockPositions</a></h2>
<p>(Re)calculate the excluded/unexcluded starts/ends</p>
<p>
</p>
<h2><a name="_terminaladd">_terminalAdd</a></h2>
<p>Makes a terminal by setting the label for it.  Not for external use.</p>
<p>
<a href="#__index__"><small>__top</small></a>
</p>
<hr />
<h1><a name="accessors">Accessors</a></h1>
<p>
</p>
<h2><a name="label">label</a></h2>
<p>Accessor for the matrix label</p>
<p>
</p>
<h2><a name="totalblocks">totalBlocks</a></h2>
<p>Returns the total blocks in the matrix (_block_accession)</p>
<p>
</p>
<h2><a name="origslice">origSlice</a></h2>
<p>Returns a slice object that is the clone of _origSlice.</p>
<p>
</p>
<h2><a name="origstructure">origStructure</a></h2>
<p>Returns reference to the ORIGINAL structure (not a clone-&gt; yet)</p>
<p>
</p>
<h2><a name="originterleave">origInterleave</a></h2>
<p>Returns the original interleave (not a clone).</p>
<p>
</p>
<h2><a name="alignblock">alignBlock</a></h2>
<p>Was clustalAlignBlock.  Align an individual block using an algorithmic aligner.  After alignment removes all columns with only gaps. If no -blk is passed aligns all bracketed blocks.</p>
<p>Needs work with paths, don't create an Output object prior to using this at present (Jan/16/06).</p>
<p><table cellspacing="0" cellpadding="0"><tr><td>Required:
<tr><td><td>-blk =&gt; @foo  (an list of blocks to align)
</table></p>
<pre>

Options:
        -unbracket =&gt; &lt;[1] | 0&gt;  when on bracketed blocks that are aligned will be turned into unbracketed blocks
        -taxa =&gt; @bar (align only for these taxa)
        -align_method =&gt; &lt; [clustalw] | muscle &gt;
        -clustal_params =&gt; '' (additional parameters to be passed to clustal)
        -muscle_params =&gt; ''</pre>
<pre>

=cut</pre>
<p><table cellspacing="0" cellpadding="0"><tr><td>sub alignBlock {
<tr><td><td>my $self = shift;
<tr><td><td>my %raw_params = @_;
<tr><td><td>
<tr><td><td>my %default_params = ('-align_method' =&gt; 'clustalw', '-clustal_params' =&gt; '', '-muscle_params' =&gt; '', '-unbracket' =&gt; 1);
<tr><td><td>my %params = (%default_params, %raw_params);
<tr><td>
</table></p>
<pre>
        $params{'-blk'} || die &quot;no -blk to alignblock\n&quot;;
        $params{'-taxa'} ||= [ $self-&gt;loopTers ];
        
        my $s = slice-&gt;new;
        $s-&gt;blocks($params{'-blk'});
        $s-&gt;taxa($params{'-taxa'});
        
        if ($params{'-unbracket'} == 1) {
                print &quot;unbracketing $params{'-blk'}\n&quot;;
                $self-&gt;blk($params{'-blk'})-&gt;bracketed(0);
        }
        
        my $fmx = $self-&gt;blk2Fastmatrix('-slice' =&gt; $s);

</pre>
<pre>
        print &quot;\naligning block: &quot;, $params{'-blk'}, &quot;\n&quot;;

</pre>
<pre>
        if ( $params{'-align_method'} eq 'clustalw') {
                $fmx-&gt;clustalAlign(%params);
        }
        elsif ($params{'-align_method'} eq 'muscle') {
                $fmx-&gt;muscleAlign(%params);
        }
        else { die 'Not a legal align_method to mx-&gt;alignBLock.'}
        
        $fmx-&gt;deleteFixedGapPositions;
        $self-&gt;fastmatrix2Blk(%params, '-fastmatrix' =&gt; $fmx);

</pre>
<pre>
        # might have changed the length of a block
        $self-&gt;blk($params{'-blk'})-&gt;blkLength( length($self-&gt;yx(0, $params{'-blk'})) );
        
        print &quot;\n&quot;;
        return 1;
}

</pre>
<p>
</p>
<h2><a name="alignsliceblocks">alignSliceBlocks</a></h2>
<p>Aligns (&lt;foo&gt;AlignBlock) all the blocks in the -slice, defaults to all bracketed blocks if no slice is passed.

</p>
<p>Options:
	-align_method =&gt; &lt; [clustalw] | muscle &gt;
	-slice
	-mode (sensu slice)
	
=cut

</p>
<p>sub alignSliceBlocks {
	my $self = shift;
	my %raw_params = @_;
	
	my %default_params = ('-align_method' =&gt; 'clustalw');
	my %params = (%default_params, %raw_params);
	
	if (not defined $params{'-slice'}) {
		my $s = slice-&gt;new;
		$s-&gt;blocks($self-&gt;loopBlocks('-mode' =&gt; 'bracketed'));
		$params{'-slice'} = $s;
	}
		
	for my $blk ($params{'-slice'}-&gt;<code>loop('Blocks'))</code> {
		$self-&gt;alignBlock('-blk' =&gt; $blk, %params)
	}
	return 1;
}

</p>
<p>
</p>
<h2><a name="blk2fastmatrix">blk2Fastmatrix</a></h2>
<p>Translates a slice to a Fastmatrix object, concatenating all blocks.  
Note that rawRowData returns origSlice if no -slice is passed.
Returns the Fastmatrix object. 

</p>
<p>
</p>
<h2><a name="fastmatrix2blk">fastmatrix2Blk</a></h2>
<p>Reverse of blk2Fastmatrix.  Merges a fastmatrix to a block.  

</p>
<p>
</p>
<h2><a name="origslicehash">origSliceHash</a></h2>
<p>For some functions (fusing blocks) it is useful to have a hash of label =&gt; @array.  This returns a default for those functions, with one block per array.

</p>
<p><a href="#__index__"><small>__top</small></a></p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" valign="middle">
<big><strong><span class="block">&nbsp;Psy::Matrix::Matrix</span></strong></big>
</td></tr>
</table>

</body>

</html>
