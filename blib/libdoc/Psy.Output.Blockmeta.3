.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Psy::Output::Blockmeta 3"
.TH Psy::Output::Blockmeta 3 "2005-11-15" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
Psy::Output::Blkmetanex
.SH "VERSION"
.IX Header "VERSION"
Version 0.02
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Output subclass for a Psy object.  
Referenced externally only.
Inherited via \s-1AUTOLOAD\s0 through Psy::Output::Output, see therein for general usage.
.PP
This output was originally concieved as a way to plot descriptive states for a given block on a tree (some nice phenetic stuff).
After some though/development on the system I found that the Lutzoni lab \s-1ARC\s0 software does more or less what I wanted to do.
.PP
Miadlikowska, Lutzoni, Goward, Zoller, Posada (2003) \*(L"New approach to an old problem: Gap-rich regions from \s-1ITS\s0 and rDNA large-subunit are incorporated into phylogenetic analyses to resolve the Peltigera canina species complex.\*(R", Mycologia 95(6):1181\-1203.
.PP
Therefor, {Miadlikowska et al., 2003 should be given credit for much of the ideas coded herin, though with very few exceptions the implementation is mine (Matt).  I have retained the character order they present for ease of comparison.  
.PP
\&\*(L"F. Kauff, J. Miadlikowska & F. Lutzoni (2003), \*(R"\s-1ARC\s0 \- a program for Ambiguous Regions Coding\*(L",
distributed by the authors (http://www.lutzonilab.net/pages/download.shtml), Dept. of Biology,
Duke University, \s-1USA\s0\*(R" hmm\- did he code this?
.PP
Their \s-1ARC\s0 characters are:
.PP
(1) sequence length,
(2)	A frequency	(no. of 'A' divided by sequence length)
(3)	C frequency	(no. of 'C' divided by sequence length)
(4)	G frequency	(no. of 'G' divided by sequence length)
(5)	T frequency	(no. of 'T' divided by sequence length)
(6)	\s-1AA\s0 frequency	(no. of '\s-1AA\s0' divided by sequence length\-1)
(7)	\s-1AC\s0 frequency	(no. of '\s-1AC\s0' divided by sequence length\-1)
(8)	\s-1AG\s0 frequency	(no. of '\s-1AG\s0' divided by sequence length\-1)
(9)	\s-1AT\s0 frequency	(no. of '\s-1AT\s0' divided by sequence length\-1)
(10)	\s-1CC\s0 frequency	(no. of '\s-1CC\s0' divided by sequence length\-1)
(11)	\s-1CG\s0 frequency	(no. of '\s-1CG\s0' divided by sequence length\-1)
(12)	\s-1CT\s0 frequency	(no. of '\s-1CT\s0' divided by sequence length\-1)
(13)	\s-1GG\s0 frequency	(no. of '\s-1GG\s0' divided by sequence length\-1)
(14)	\s-1GT\s0 frequency	(no. of '\s-1GT\s0' divided by sequence length\-1)
(15)	\s-1TT\s0 frequency	(no. of '\s-1TT\s0' divided by sequence length\-1)
(16)	A pairing	(no. of '\s-1AA\s0' divided by total no. of 'A')
(17)	C pairing	(no. of '\s-1CC\s0' divided by total no. of 'C')
(18)	G pairing	(no. of '\s-1GG\s0' divided by total no. of 'G')
(19)	T pairing	(no. of '\s-1TT\s0' divided by total no. of 'T')
(20)	A distribution	(no. of spaces between 'A' divided by total no. of 'A')
(21)	C distribution	(no. of spaces between 'C' divided by total no. of 'C')
(22)	G distribution	(no. of spaces between 'G' divided by total no. of 'G')
(23)	T distribution	(no. of spaces between 'T' divided by total no. of 'T')
(24+x)	motif presence [1] or absence [0] ### \s-1NOTE\s0 \s-1THAT\s0 \s-1THIS\s0 \s-1IS\s0 \s-1DEFINED\s0 a\-priori ###
.PP
Noteable differences from their methods are as follows:
1) Psy has no amino acid functionality.
2) Psy can not read \s-1ARC\s0 formated input (yet)
3) The motif presence/absence (character 24+x) has been extended by allowing for automatic generation of motifs based on sampleing the data (kwords).
4) Several addition characters have been added (length, counts rather than pct).
5) Outputting is much more flexible, as it is integrated into overall slice/matrix functinos available to Psy.  Available output formats are now 2 types of nexus files formatted for use in Mesquite and at \s-1TNT\s0 readable format.
.PP
n) Pair counts are sliding in Psy, I need ot check if they are so in \s-1ARC\s0.  e.g. '\s-1AAAA\s0' has 3 '\s-1AA\s0' pairs, not 2.
.PP
Required parameters
	\-mx
.PP
Optional parameters
	'\-out_format' => < mesquite_chr_by_blk | mesquite_blk_by_chr | [tnt] | original_arc >
.PP
If a \-slice is passed it will be used for taxa partition.  In absence of \-plan it will also be used in place of origSlice (see below).
.PP
If no \-plan is given each block? in the origSlice will be individually translated to metachars.
.PP
A \-plan can be made as follows: 
.PP
.Vb 5
\&        my $p;
\&        $p->{0}->{blks} = ([0 1 2 3 4]); # block 0 will be a fusion of blocks 0..4.  Required.  
\&        $p->{0}->{name} = 'foo';  # block 0 label will be 'foo'.  Not necessary, defaults to the index if not set.
\&        $p->{0}->{type} = 'trans'; # block 0 will be translated to meta characters or left as nucleotide < 'trans' | 'orig' >.  Not required, defaults to 'trans' if not set.
\&        $p->{1} ...
.Ve
.PP
.Vb 1
\&        '-plan' => $p
.Ve
.PP
.Vb 1
\&        And used like:
.Ve
.PP
.Vb 2
\&        my $o = output->new();
\&        $o->Blockmeta('-mx' => $mx, '-plan' => $p);
.Ve
.PP
If \f(CW$mx\fR is a matrix, a plan can also be generated like:
	my \f(CW$p\fR = \f(CW$mx\fR\->plan;
