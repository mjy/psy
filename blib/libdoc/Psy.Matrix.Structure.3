.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Psy::Matrix::Structure 3"
.TH Psy::Matrix::Structure 3 "2009-05-25" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
Psy::Matrix::Matrix
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Builds a structure object, at present based on a helix-index file (but see also Psy::Matrix::_load_PHASE_simulate). 
.PP
.Vb 5
\&    use Psy::Matrix:Structure;  
\&        my $fs = structure->new(
\&                                                '-helix_index' => 'Evaniodea.index.0.02.txt',
\&                                                '-path' => '../../data/evan/',          
\&                                        );
.Ve
.PP
.Vb 2
\&        print Dumper($s);
\&        print $s->{blocks}->version();
.Ve
.Sh "new"
.IX Subsection "new"
Create a new object, not for direct reference/use.
.Sh "helix"
.IX Subsection "helix"
An accessor, if two blocks passed makes a helix with block 1 = 5', block 2 = 3'; with one block passed returns 3'.
.Sh "stockholm1RFLine"
.IX Subsection "stockholm1RFLine"
Returns a stockholm legal \s-1RF\s0 line
.Sh "phase2Mask"
.IX Subsection "phase2Mask"
Return a formated, \s-1PHASE\s0 2.0 legal mask in one full string.
.Sh "phase2Class"
.IX Subsection "phase2Class"
Returns a semi-complete class line for use in \s-1PHASE\s0 2.0 analyses
.Sh "phansyMaskChars"
.IX Subsection "phansyMaskChars"
Returns a hash of block\->mask\-letter. Used for translating () masks to <> or aA masks.
.PP
Algorithm could be very likely be greatly simplified by recursion, but it *appears* to work as is (its ugly!).
.Sh "sliceMask"
.IX Subsection "sliceMask"
Returns the mask for a slice as a string, substitutes {bracket_chars} if passed, inserts \-blk_spacer character between blocks if passed. If a \-mx and \-bracketed_blocks == 1 then mask will be spaced accordingly.
.Sh "mask"
.IX Subsection "mask"
Returns the mask for a block.
.Sh "maskPair"
.IX Subsection "maskPair"
Returns hash with paired masks under '5prime' and '3prime' indicies.
.Sh "bracketsInMask"
.IX Subsection "bracketsInMask"
Returns a count of the number of parens for a given block.
.Sh "nucPairs"
.IX Subsection "nucPairs"
Returns a hash with keys {pairs) pointing to 5':3' pair positions (MrBayes 'pairs') and {nucs} a list of all positions (column indicies).
.PP
To count from 0 set zero_beers = 1
.Sh "basePairs"
.IX Subsection "basePairs"
Returns a hash of basepairs encountered, strictly adhering to \f(CW$alphabet\fR;
.PP
Not done.
.Sh "alignedHelices"
.IX Subsection "alignedHelices"
Returns a hash of keys (mask1, mask2, stem1, stem2) with the stems/masks aligned
.Sh "block_helix_label"
.IX Subsection "block_helix_label"
A label accessor.
.Sh "deleteHelix"
.IX Subsection "deleteHelix"
Deletes a helix.  Unproven.
.Sh "threePrimePair"
.IX Subsection "threePrimePair"
Given a 3' helix index return the 5' complement (missing the faster way to reverse hashes\- fix).
.Sh "loopHelices"
.IX Subsection "loopHelices"
Returns an array of 5' helix sides within a slice 
.PP
!! needs to limit those to fully (3'/5') bound by slice only !!  
## reduntant with mx\->loopblocks (keep this one) ##
.PP
# slice dependant, it's not a helix unless the passed slice has both blocks?
.Sh "loopStems"
.IX Subsection "loopStems"
Returns an array of all block indices involved in pairing given the particular \-slice
.Sh "loopBasePairs"
.IX Subsection "loopBasePairs"
Returns an array of basepairs for a given 5' block index, assumes mask is made of '()'
.PP
Requires \-mx, \-blk, \-ter
.Sh "loopNonBasePairs"
.IX Subsection "loopNonBasePairs"
\&\s-1NOT\s0 \s-1IMPLEMENTED\s0
Returns an array of the positions of non paring columns 
.Sh "pseudoKnotPairs"
.IX Subsection "pseudoKnotPairs"
A hack.
.PP
Takes an array representing a hash of indices represent helix pairs.
.PP
Returns an array pointing to the 5' blocks which, when removed along with their 3' pair, will leave remain blocks psuedoknot free.
.PP
Note that there are multiple solutions possible, and that the result returned here is very inefficient (i.e removes the fewest number of helices making the overall structure pseudoknot free).
Someone with more experience will need to solve the most efficient problem.
.PP
Use with caution, and possibly in combination with manually selected helicies.
.Sh "loopPairs"
.IX Subsection "loopPairs"
Returns a array of 1\-n where n is the number of brackets.
.PP
Requires \-mx, \-blk 
.Sh "pairPos"
.IX Subsection "pairPos"
Returns a two value array of column indices (unbracketed position) for the \-pos position of the helix defined by the 5' \-blk.
Requires \-blk, \-mx, \-pos.
Similar to nucPairs but notably counts from \s-1ZERO\s0.  Primarily for internal use.
