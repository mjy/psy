
sub out_inaase () { 
	# This code written early in the project and it hasn't 
	# been touched for a long time. Tt did work in the past, it likely won't now (dec/04/04)
	
	my (	
		$input, 	# input object
		$slice,
		$icorrect,	# correct bracketed columns - (0) - no; (1) - yes
	) = @_;

	my @tmp_matrix = @mx;
	
	# [DATA = DNA] BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD
	
	# to do:
	# - add a verbose arguement for debuging to screen?
	
	# requires: mxdesc
	# required by:

	my $icurregion =0; 	# from 0 to 54 regions allowed currently in INAASE
	my $ifile = 0; 		# the current inaase file being written to remember, 55 regions only
	my $imaxblklen = 101; 	# set to the maximum length of block that inaase can handle (101) or less to export only those blocks < a given size
	my $fix = 1;		# loop marker
	my $nextotchars;
	my @tmpstats = ();
		
	# WARNING - The following array is filled with blocks specific to a given analysis, it is manually set to exlude blocks producing errors as noted in CompAlign
	#my @manual_excludes = (55,95,113,114,123,125,135,136);

	print "\n\ngenerating INAASE output\n\n";
	
	#if ($#manual_excludes > 0) {print "\n\nWARNING!!! out_inaase is set to exclude characters A-PRIORI!!!  Double check that you want to do this. \n\n"}
	
	my @invars =(); # array to store columns to "fix" (now = exclude)

	# directory functions
	chdir($rootdir);
	&io_confirmdir("analyses/inaase/$input->{Modelroot}");

	# call to out_mx - needs to be done before correcting the data in inaase
	# merge output from Inaase with this file
	
	open (INAASEFH, ">$input->{Modelroot}-inaase.nex") || die "couldn't open file to output html too - \n";

		print INAASEFH "[YOU WILL NEED TO EDIT THE nchar variable - changing it to the value reported in $input->{Modelroot}-inaase_merge2nex.txt ]\n";
		print INAASEFH "[YOU ALSO NEED TO COMMENT OUT THE DATA = DNA line!!]\n";
		@tmpstats = &out_mx (*INAASEFH, $slice, 1, 0, 0, 0, 0, "", 0, 0, 2, $defaultcolstart, 0, 0 , 0);
		print "nextotchars: $tmpstats[0]\n";;
		$nextotchars = $tmpstats[0];

		print INAASEFH "\n\n [ 1) paste contents of Inaase-Generated StepMatrix HERE]\n";
		print INAASEFH "[ 2) cut the matrix portion of StepMatrix and place it BEFORE the \"; end;\" directly above these lines]\n";
		print INAASEFH "[ 3) add the word \"interleave\" ]\n\n";
		
		print INAASEFH "end;\n";
		
	close INAASEFH;

# INAASE currently handles 55 ambiguous regions, 200 taxa, 100 sites per region, 2500 sites total, 32 character step matricies

# inaase file must do two things:
# 1) generate the outfile(s) minus bracketed blocks to be used (out_mx with no brackets on)
# 2) generate the matrix to be combined with the inaase file(s)

# break large files into multiple INAASE files - there are several ways to do this, the simplest is to just make n files, all with all the data, but different header rows telling inaase which data to convert.  This works well for datasets < 2500 sites total.  If there are > 2500 sites then its easier to parse out the blocks you need.  The program is currently not set to parse inaase-only data > 2500 chars as multiple files.

# "correcting code"
# do corrective pass (add c colum to those regions without any infomative regions (all dashes)
# need to rewrite to allow for sets of taxa/range of blocks to be defined

my $invariant =1;
my ($curchar, $invarchar);

	# 2 part strategy 1) correct (replace in) all the data by replacing illegal characters; 2) Find invariant blocks
	if ($icorrect == 1) {
		foreach my $blk ($slice->loop("Blocks")) {
			if ($nbd[$blk][3] ==1) {
				foreach my $t ($slice->loop("Taxa")) {
				
				# " INAASE can only handle - (gaps), ? (question mark) for unknown sites and the nucleotide
				# codes (A, C, G, T) but not the IUPAC-IUB Ambiguity Codes (R, Y, K, M, S, W etc.). "
				
				#ensure the above is the case, though note INAASE 2.3b does not catch errors well *at all* ------!!!! this is bad , shoudl use temps in output !!!! ----
					$mx[$t][$blk][0] =~ s/U/T/ig; # need to translate U's to T's
					$mx[$t][$blk][0] =~ s/(?)([^ATGC\-\?])/?/ig;  # need to translate all other codes to ?  <-- what about N?
				}
			}
		}

	# find invariant blocks
		foreach my $blk ($slice->loop("Blocks")) {
			if ($nbd[$blk][3] == 1) {
				$invariant = 1;
				 for (my $p=0; $p < $nbd[$blk][0]; $p++) { 		# loop through all positions in the string
					if ($invariant == 0 ) {	last }
					
					foreach my $t ($slice->loop("Taxa")) { 		# loop through the taxa - remember smaller subsets may have all dashes, while larger
						
						$mx[$t][$blk][0] =~ /.{$p}(.)/;
						$curchar = $1;
						
						if ($t == $slice->first("Taxa") ) {
							$invarchar  = $curchar; 
						}
						unless ($curchar eq $invarchar)  {$invariant = 0; last}
					}
				}
				if ($invariant == 1) {push @invars, $blk}
			}
		}
		
	# EXPERIMENTAL - INAASE Barfs on some two column blocks that have two states only (eg: col1: --------t; col2: -t-t-t-ttt) - the following code should catch these
	# find "apomorphic blocks" - is this really number of columns - number states ?  must be some relationship there?			
			foreach my $blk ($slice->loop("Blocks")) {
				if ($nbd[$b][3] == 1) { # check bracketed blks only
					my $allchars = "";

					foreach my $t ($slice->loop("Taxa")) { # loop through the taxa - remember smaller subsets may have all dashes, while larger
						$allchars .= $mx[$t][$blk][0];
					}
			
					if (&str_totaluniquechars($allchars) < 3) {
						push @invars, $blk;
						print "bracketed block $blk less than 3 states \n";
					}
				}
			}
	}
	
		print "invariant or apomorphic blocks: @invars\n";
		#print "some blocks were exlcluded manually: @manual_excludes \n";
	
	# merge invariant and manullly excluded blocks
	# push (@invars, @manual_excludes);
	
# end inaase pre-parse
# pass through the block range and determine how many inaase files will be needed to parse the blocks of 55

	 # this is dumb!!! build an interleave then loop through it, new inaase file for each interleave!!!
	
my $debugon = 0;

	my ($icuri, $iblklength, $iblktot) = (0) x 3;
	my (@idesc);
	$idesc[$icuri][0]=0;		# mark the literal starting block of the first inaase file (including all blocks) not very useful now
	$idesc[$icuri][4]=0;		# mark the starting point from which to split the inaase block string
	
	foreach my $x ($slice->loop("Blocks")) {
		# if the region is bracketed, and below minimum length, and not invariant add one, increment the block for the current value
		if (($nbd[$x][3]==1)  and ($nbd[$x][0] < $imaxblklen) and (not (grep($_ == $x, @invars)))) {
			$iblktot++;
			$iblklength += $nbd[$x][0];
		}

		# check for new file marker
		if ($iblktot==54) {
			$idesc[$icuri][1] = $x; 		# mark the current end point (literal)
			$idesc[$icuri][2] = 55; 		# mark the total number of blocks 55, not 54+0, since inaase counts from 1, not zero
			$idesc[$icuri][5]= ($icuri+1)*54;	# mark the end point to which to split the innasse block string from (starts at zero!)	
			$idesc[$icuri][6] = $iblklength;

			$iblklength=0;
			
			$icuri++;
			$idesc[$icuri][0] = $x+1; 	       # mark the literal start of the next block
			$idesc[$icuri][4] = ($icuri*54)+1;     # mark the inaase split string point
			$iblktot=0;
		}
	}

	# mark the end point of the last block
	$idesc[$icuri][1] = $slice->final("Blocks"); # this might be in error with slice revision
	$idesc[$icuri][2] = $iblktot; # used to be +1this is plus one because inaase counts from 1, not zero
	$idesc[$icuri][5]= ($icuri+1)*54 + $iblktot;
	$idesc[$icuri][6] = $iblklength;

	# finished with block parsing
	
	# some user msgs
		print "total inaase blocks: $iblktot \n";
		print "\ninaase output files: ($icuri+1)\n";
		for (my $x=0; $x<$icuri+1; $x++) {
			print "$x\tstart:$idesc[$x][0]\tend:$idesc[$x][1]\t$idesc[$x][2]\n";
		}

	# end det of how many inaase blocks needed when ALL data is included! - a little crude but still used below
	
	#build individual inaase descriptions for inaase-only output files
	
	my (@itranpos, @inumstr);
		for (my $i=0; $i <$icuri+1; $i ++) {
		my $itranpos = 1; #reset for each new block
		
		for (my $j=$idesc[$i][0] ; $j<$idesc[$i][1] ; $j++) { #loop through all blocks (bracketed and un) containing the ith 55 blocks
			if (($nbd[$j][3]==1)  and ($nbd[$j][0] < $imaxblklen) and (not (grep($_ == $j, @invars)))) {
			#if ($nbd[$j][3]==1 and $nbd[$j][0] < $imaxblklen ) { # only working with bracketed blocks now!
					
				$inumstr[$i] .= $itranpos;
				$itranpos += $nbd[$j][0]-1;
				$inumstr[$i] .= "-$itranpos ";
				$itranpos ++;
				
				#do some error checking here for >2500? -------------------- later
			}			
		}	
	}	

	#debug
	#for ($o=0; $o<4; $o++) {
		#	print "$mx[$o][6][0] $mx[$o][7][0] $mx[$o][8][0]\n";
	#}

	#@iblks = split  (/\s+/, $inaaseblks);  # used in "full dataset" mode DEBUG

	# write the files to be parsed by Inaase
	for ( my $x=0; $x<$icuri+1; $x++) {

		my $outfile = "jrna_inaase$x.txt";

		open (WRITEHNDL, ">$outfile") || die "couldn't open file to output INNASE too - \n";

		print WRITEHNDL $slice->total("Taxa");		#number of taxa
		print WRITEHNDL "\t";
		print WRITEHNDL $idesc[$x][6];			# number of chars		
		print WRITEHNDL "\t";
		print WRITEHNDL $idesc[$x][2]; 			# number of subblocks $numbrakblks;
		print WRITEHNDL "\t-\t?\t\n"; 			# gap char, missing char

		# print WRITEHNDL "$inaaseblks\n";				# maintain, this is the master list for debugging purposes
		# print WRITEHNDL "@iblks[$idesc[$x][4]..$idesc[$x][5]]\n";	# this is the format for including unbracketed data for inaase
 		
		print WRITEHNDL "$inumstr[$x]\n";
		
		$debugon = 1;
		
		foreach my $t ($slice->loop("Taxa")) {
			#$padlen = 45-length({$ters{$t}});
			#$padname = sprintf ("%-${padlen}s", $ters{$t});
	
			print WRITEHNDL "$ters{$t} "; # $padname;	#print the taxon name
				
				my $indexdebug =1;
				#export only the blocks that are bracketed
				for (my $blk=$idesc[$x][0] ; $blk<$idesc[$x][1] ; $blk++) { #loop through all blocks (bracketed and un) containing the ith 55 blocks
					if (($nbd[$blk][3]==1) and ($nbd[$blk][0] < $imaxblklen) and (not (grep($_ == $blk, @invars)))) {
						#if ($nbd[$b][3]==1 and $nbd[$b][0] < $imaxblklen  ) { #   only working with bracketed blocks of size < 101 
						print WRITEHNDL $mx[$t][$blk][0];
						#print WRITEHNDL " ";

						#use this code to help determine which blocks to manually exclude from the data based on compalign
						if ($debugon == 1) {
							print "literal block <- $blk $indexdebug -> CompAlign Region#\n";
							$indexdebug++;
						}
					}
						
				}	
			$debugon =0;
			print WRITEHNDL "\n";
		}

	close (WRITEHNDL); 
	}

	open (INAASEFH, ">$input->{Modelroot}-inaase_merge2nex.txt") || die "couldn't open file to output html too - \n";
		print INAASEFH "[change the number of characters to ";
		print INAASEFH $nextotchars + $iblktot; # used to be + 1, not correct;
		print INAASEFH "; depending on where you paste the inaase generated characters you may also have to add the word \"interleave\"]\n";
 		print INAASEFH "[paste below inside the nexus file, at the bottom of the inaase step-matrix assumptions block, before the end;]\n\n";
		print INAASEFH "typeset *untitled = ";
		
		for (my $i=1; $i < $iblktot+1; $i++) {
			print INAASEFH "Region#$i\: ";
			print INAASEFH $nextotchars+$i;
			print INAASEFH ", ";
			#print ($i % 4);
			 if  (($i % 4) == 1) {print INAASEFH "\n"} ;
		 }

		print INAASEFH "unord: 1-$nextotchars;\n\n"; #printing range is correct
		
		print INAASEFH "wtset *untitled [EqualWts] = 1: all;\n";
		print INAASEFH "exset *untitled [AllIncl] = [none];\n\n";

		print INAASEFH "[paste below at very end of nexus file]\n\n";
		print INAASEFH "begin PAUP;\n";
		print INAASEFH "delete/only;\n";
		print INAASEFH "outgroup/only;\n";  
		print INAASEFH "assume ancstates=standard;\n";
		print INAASEFH "end;\n";
	close INAASEFH;

	@mx = @tmp_matrix; # return @mx to uncorrected original matrix
	
} # end sub out_inaase

