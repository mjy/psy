.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Psy::Matrix::Matrix 3"
.TH Psy::Matrix::Matrix 3 "2009-05-25" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
Psy::Psy
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
my \f(CW$foo\fR = matrix\->new(
						'\-filename' => 'Evanioidea.0.04.Nex',
						'\-path' => '../../data/evan/',
						'\-number_terminals' => '59'  # n\-1
					);
.PP
#print \*(L"\en\*(R";
#print Dumper($foo);
#print \*(L"\en\*(R";
#print \f(CW$foo\fR\->{blocks}\->\fIversion()\fR;
.PP
use Psy::Matrix;
.PP
my \f(CW$foo\fR = matrix\->\fInew()\fR;
    ...
.SH "OBJECT"
.IX Header "OBJECT"
.Sh "_load"
.IX Subsection "_load"
Internal.  Used to load Psy/jRNA formats and Stockholm format.  
.PP
Needs an over-ride ultimately, likely to set to a single filetype, or better yet to a parser/lexer.
.Sh "_load_PHASE_simulate"
.IX Subsection "_load_PHASE_simulate"
\&\s-1NOT\s0 \s-1WORKING\s0!
.PP
Loads a file generated by \s-1PHASE\s0 2.0(beta)'s simulate package.  
.PP
At this point it handles only a \s-1MIXED\s0 model, where the second model is \s-1RNA\s0 with a repeating () structure (the first parition is essentially ignored. 
.PP
You must include a \-struct_size of 2 or larger.  For example if your simulate structure is () then struct_size = 2. (()) = 4 etc. 
.Sh "ter"
.IX Subsection "ter"
Returns the terminal _object_ for the passed index.
.PP
.Vb 1
\&        Smx->ter(2);
.Ve
.Sh "blk"
.IX Subsection "blk"
Returns the block meta-data _object_ (not index) for a given block ## \s-1COMPLETE\s0 to full accession? (low priority).
	Smx\->\fIblk\fR\|(2);
.Sh "cell"
.IX Subsection "cell"
Returns the sequence data for a \-ter, \-col pair.
.PP
.Vb 1
\&        Smx->cell('-ter' => 1, '-col' => 2);
.Ve
.Sh "rawCell"
.IX Subsection "rawCell"
Returns sequence data minus the regex \-gapchar for a \-ter, \-col pair.
.PP
.Vb 2
\&        Smx->cell('-ter' => 1, '-col' => 2, '-gapchar' => '-'); OR
\&        Smx->cell('-ter' => 1, '-col' => 2, '-gapchar' => '[ACT]');
.Ve
.Sh "yx"
.IX Subsection "yx"
Returns sequence data in a yx accessor for matrix, only returns values! 
.PP
.Vb 1
\&        Smx->yx(1,2);
.Ve
.Sh "rawRowData"
.IX Subsection "rawRowData"
As in rawCell, but across a given row\- overwritten by a \-slice.
.PP
.Vb 6
\&        $mx->rawRowData(
\&                '-gapchar' => '-',
\&                '-u2t' => 0,
\&                '-slice' => $my_slice,
\&                '-legal_alphabet' => $alphabet
\&        );
.Ve
.Sh "column"
.IX Subsection "column"
Returns a column vector (string).
.PP
Requires either \-col \s-1OR\s0 \-pos and \-blk.
.PP
If \-blk is passed then \-col is reference to position in block (0 is first position).
.PP
Usage: 
	Smx\->column(
		'\-blk' => 0,
		'\-pos' => 1,
	);
	\s-1OR\s0
	Smx\->column(
		'\-col' => 32
	);
.PP
See also columns package.  No bracketed columns can be returned.
.Sh "rowAsArray"
.IX Subsection "rowAsArray"
\&\-returns the sequence data for a given taxa for a given \-slice as an array of blocks of length \-max_seq_length
\&\-strips the \-gapchar regex if provided prior to calculating the length
\&\-cleans the data if \-alphabet and \-clean set
.Sh "rowData"
.IX Subsection "rowData"
\&\-returns all blocks of data for a given row, overwritten by slice if provided
\&\-strips the \-gapchar regex if provided prior to calculating the length
\&\-cleans the data if \-alphabet and \-clean set
.Sh "blockData"
.IX Subsection "blockData"
Returns an array of all blocks of data for a given \-blk, takes \-slice too.
.PP
.Vb 4
\&        Smx->blockData(
\&                '-blk' => 0,
\&                '-slice' => $my_slice,
\&        );
.Ve
.Sh "sliceData"
.IX Subsection "sliceData"
Returns an array (\s-1DON\s0'T \s-1DEPEND\s0 \s-1ON\s0 \s-1ORDER\s0) containing all data in the passed slice, if no slice is passed the original slice (all data) is returned.
.PP
.Vb 3
\&        Smx->sliceData(
\&                '-slice' => $my_slice,
\&        );
.Ve
.Sh "numBracketedBlocks"
.IX Subsection "numBracketedBlocks"
Returns the count of the total number of bracketed blocks, overides with \-slice
.Sh "colInBlk"
.IX Subsection "colInBlk"
Returns the block index to which \-col (the column) can be found within.
.PP
Two modes: \-mode => includebracketed | excludebracketed, defaults to later.
.Sh "loopBlocks"
.IX Subsection "loopBlocks"
Returns an ordered array of block indices for the given slice of particular type, similar functions availible for slice objects.
.PP
Hmm.  Likely need to merge with slice object.
.PP
Legal values for 
	\-mode => < unbracketed | bracketed | [all] | fiveprime > 
.Sh "plan"
.IX Subsection "plan"
Returns a basic 'plan', which is essentially a directive to fuse or not fuse paritions.
	'\-mode' => < [basic] (recoded bracketed blocks) | all (recode all blocks) | all_fused (returns 1 big partition = the full slice) >
	'\-slice' => '$self\->origSlice'
.Sh "fragmentHash"
.IX Subsection "fragmentHash"
Returns a hash of unique fragments, and their total. 
.Sh "lastBlockIndex"
.IX Subsection "lastBlockIndex"
Returns the index of the last block.
.Sh "insertBlock"
.IX Subsection "insertBlock"
Not tested/finished.
.Sh "terLabel2Index"
.IX Subsection "terLabel2Index"
Returns the index of a given terminal \-label
.Sh "totalChars"
.IX Subsection "totalChars"
Returns the total number of characters for a given slice (defaults to whole matrix) for the given \-slicemode
	\f(CW$mx\fR\->totalChars(
		'\-slicecharmode' => 'all'
	);
.PP
Options:
	'\-slicecharmode' => < all | [unbracketed] | bracketed >
.Sh "loopTers"
.IX Subsection "loopTers"
Returns a sorted array of _indicies_ to the taxa in the matrix (no slice override)
.Sh "lengthLongestTer"
.IX Subsection "lengthLongestTer"
Returns the length of the longest taxon name in a slice
.Sh "numberer"
.IX Subsection "numberer"
Numbers blocks or columns. Includes one big string with line endings. Deprecated reference to a particular interleave
.PP
.Vb 7
\&                -mode' => 'unbracketed',
\&                -numbering_mode' => 'col',
\&                -blk_spacer' => '',
\&                -gap_chr' => ' ', # inserted b/w blocks
\&                -number_bracketed' => 0, # number the bracketed blocks, or not
\&                -start_col' => 1,
\&                -original_indexing' => 0
.Ve
.Sh "_calcBlockPositions"
.IX Subsection "_calcBlockPositions"
(Re)calculate the excluded/unexcluded starts/ends
.Sh "_terminalAdd"
.IX Subsection "_terminalAdd"
Makes a terminal by setting the label for it.  Not for external use.
.SH "Accessors"
.IX Header "Accessors"
.Sh "label"
.IX Subsection "label"
Accessor for the matrix label
.Sh "totalBlocks"
.IX Subsection "totalBlocks"
Returns the total blocks in the matrix (_block_accession)
.Sh "origSlice"
.IX Subsection "origSlice"
Returns a slice object that is the clone of _origSlice.  
.Sh "origStructure"
.IX Subsection "origStructure"
Returns reference to the \s-1ORIGINAL\s0 structure (not a clone\-> yet)
.Sh "origInterleave"
.IX Subsection "origInterleave"
Returns the original interleave (not a clone).
.Sh "alignBlock"
.IX Subsection "alignBlock"
Was clustalAlignBlock.  Align an individual block using an algorithmic aligner.  After alignment removes all columns with only gaps. If no \-blk is passed aligns all bracketed blocks.
.PP
Needs work with paths, don't create an Output object prior to using this at present (Jan/16/06).
.PP
Required:
	\-blk => \f(CW@foo\fR  (an list of blocks to align)
.PP
Options:
	\-unbracket => <[1] | 0>  when on bracketed blocks that are aligned will be turned into unbracketed blocks
	\-taxa => \f(CW@bar\fR (align only for these taxa)
	\-align_method => < [clustalw] | muscle >
	\-clustal_params => '' (additional parameters to be passed to clustal)
	\-muscle_params => ''
.Sh "alignSliceBlocks"
.IX Subsection "alignSliceBlocks"
Aligns (<foo>AlignBlock) all the blocks in the \-slice, defaults to all bracketed blocks if no slice is passed.
.PP
Options:
	\-align_method => < [clustalw] | muscle >
	\-slice
	\-mode (sensu slice)
.Sh "blk2Fastmatrix"
.IX Subsection "blk2Fastmatrix"
Translates a slice to a Fastmatrix object, concatenating all blocks.  
Note that rawRowData returns origSlice if no \-slice is passed.
Returns the Fastmatrix object. 
.Sh "fastmatrix2Blk"
.IX Subsection "fastmatrix2Blk"
Reverse of blk2Fastmatrix.  Merges a fastmatrix to a block.  
.Sh "origSliceHash"
.IX Subsection "origSliceHash"
For some functions (fusing blocks) it is useful to have a hash of label => \f(CW@array\fR.  This returns a default for those functions, with one block per array.
