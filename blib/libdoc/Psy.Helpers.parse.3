.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Psy::Helpers::parse 3"
.TH Psy::Helpers::parse 3 "2005-11-15" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
Raw seq parser
.SH "VERSION"
.IX Header "VERSION"
Version 0.02
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Prolly not for public consumption.
.PP
Code to recursively parse a directory of .seq files and return some a file of nicely formatted concensus data that can be manually edited, then extracted.
Makes *a lot* of assumptions about how the seq files are named, but the general pattern is:
letter##_code.primer_lane.file_ending (e.g. g02_mjy234.D2_01.seq). 
.PP
You must include your primer pairs in \s-1DATA\s0 (bottom of this file), they are used in matches and can be abused to limit the output generated.
.PP
In its simplest form just do this:
.PP
.Vb 3
\&        use sp;
\&        my $foo = sp->new('-dir' => '.');
\&        $foo->dumpAll;
.Ve
.PP
After editing your output this returns a fasta formatted version of the data:
.PP
.Vb 2
\&        use postsp;
\&        &postsp::extractToMx('out4.text');
.Ve
.SH "postsp"
.IX Header "postsp"
Post processing of sp output 
.Sh "extractToMx"
.IX Subsection "extractToMx"
A hack to generate a table that is easily mappable to import to mx.  The primer hash values are gene_ids.
.SH "sp"
.IX Header "sp"
sp (sequence parser), for rapid pre-editing formatting of .seq files
.Sh "loadDir"
.IX Subsection "loadDir"
Loads (recursively) the seq files.
.Sh "readSeq"
.IX Subsection "readSeq"
Reads an individual sequence
.PP
## change this to the electropherogram once BioPerl-ext installs correctly
.Sh "concensus"
.IX Subsection "concensus"
Returns a concensus sequence
\&\- assumes str1 and str2 are equal lenght
\&\- for columns opposite whitespace concensus returns lower case
\&\- for non-matching columns \*(L"N\*(R" is entered
\&\- otherwise the concensus letter is entered
.Sh "concensusCue"
.IX Subsection "concensusCue"
Symbolizes a concensus string for easier visual-reference
.Sh "aeStr"
.IX Subsection "aeStr"
Align and equalize string: adds space offset (calc offset with &align) to begining of string 1, then caps then end of the then longer string with space so that both are equal length
.Sh "align"
.IX Subsection "align"
A simple very rough \*(L"alignment\*(R" algorithm for near identical sequences of large length (e.g. forward and backwards reads). Returns the offest of seq1 to seq2; no gaps are inserted
.Sh "pair"
.IX Subsection "pair"
Pairs a forward and reverse sequence by elements of their filenames \s-1AND\s0 the <\s-1DATA\s0> that describes primer pairs
.Sh "### accessor methods ###"
.IX Subsection "### accessor methods ###"
.Sh "match"
.IX Subsection "match"
The match string, like '\s-1MY154\s0'
.Sh "sample_pair"
.IX Subsection "sample_pair"
like 'A', 'B' etc.
.Sh "_pair_letter"
.IX Subsection "_pair_letter"
Used to match. \s-1NO\s0 \s-1LONGER\s0 \s-1USED\s0.
.PP
Assume its all nice ascii\- this might not ultimately be the case (A/H wrapping).
.Sh "primer"
.IX Subsection "primer"
Primer for a seq
.Sh "threePrime"
.IX Subsection "threePrime"
Accessor for the 3' for a 5'\-3' primer pair, as read from <\s-1DATA\s0>.
.Sh "voucher_code"
.IX Subsection "voucher_code"
Voucher code 
.Sh "seq"
.IX Subsection "seq"
Seq (nucleotides) 
