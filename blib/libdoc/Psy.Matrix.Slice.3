.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Psy::Matrix::Slice 3"
.TH Psy::Matrix::Slice 3 "2005-11-15" "perl v5.8.7" "User Contributed Perl Documentation"
.SH "NAME"
Psy::Matrix::Slice
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
A slice object.  Slices are essentially character and/or terminal partitions (sets).  Characters are used in the sense of blocks, not columns of data (though a block can be length 1).  
The object uses hashes rather than arrays so that set operations are easy.
.PP
.Vb 2
\&        use Psy::Matrix::Slice; 
\&        my $s = slice->new();
.Ve
.Sh "new"
.IX Subsection "new"
.Sh "clone"
.IX Subsection "clone"
Returns a clone of the object
.Sh "blocks"
.IX Subsection "blocks"
Adds/accesses block has (indicies, not objects).  Returns a hash, not an array.
Usage:	
	\f(CW$s\fR\->blocks(0, 1, 2, 45..65, 3);
	\f(CW@foo\fR = \f(CW$s\fR\->blocks;
.Sh "taxa"
.IX Subsection "taxa"
As blocks but for taxa.
.Sh "remove"
.IX Subsection "remove"
Removes blocks \s-1OR\s0 taxa.
.PP
Usage:
.PP
.Vb 3
\&        my @remove_me = (3, 9, 10, 11, 13, 14..25);
\&        $s->remove('Blocks', @remove_me);       
\&OR
.Ve
.PP
.Vb 1
\&        $s->remove('Taxa', 3, 9, 10, 2..4);  # note overlaps (e.g. 3) don't fail, and order doesn't matter
.Ve
.Sh "loop"
.IX Subsection "loop"
Returns ordered list of taxa \s-1OR\s0 blocks as array.
.PP
Usage:
.PP
.Vb 3
\&        my @foo = $s->loop('Taxa');
\&        OR
\&        for my $blk ($s->loop('Blocks') { ... }
.Ve
.Sh "union"
.IX Subsection "union"
Returns a union of two hashes, that are referenced like \f(CW$first\fR\->{$hash}, \f(CW$second\fR\->{$hash}.
.PP
Used internally like \f(CW$s1\fR\->{'Blocks'}, \f(CW$s2\fR\->{'Blocks'}
.Sh "difference"
.IX Subsection "difference"
As union, but returns difference.
.Sh "total"
.IX Subsection "total"
Returns total blocks/taxa.
Usage: 	
.PP
.Vb 1
\&        print "total blocks: ", $s->total('Blocks');
.Ve
.PP
Not zero beers.
.Sh "first"
.IX Subsection "first"
Return the first block \s-1OR\s0 taxon in the slice (as ordered by integer index).
.Sh "final"
.IX Subsection "final"
Return the final ('last' is reserved word) block \s-1OR\s0 taxon in the slice (as ordered by integer index).
.Sh "lengthLastBlk"
.IX Subsection "lengthLastBlk"
Returns the string length of the last block (e.g. 2000 has length 4). 
.Sh "describe"
.IX Subsection "describe"
Returns a text description of the slice, formatted for human reading.
.Sh "decribeCoded"
.IX Subsection "decribeCoded"
Returns a text description of the slice, formatted for \fIeval()\fR or use in batch\-file.
.Sh "random"
.IX Subsection "random"
Returns an index to a randomly selected taxa \s-1OR\s0 block.
.Sh "newRandomSlice"
.IX Subsection "newRandomSlice"
Returns a reference to a new slice object with randomly selected blocks and taxa.
.PP
Usage:
.PP
.Vb 3
\&        $foo = $s->new_random_slice();
\&        OR 
\&        $foo = $s->new_random_slice("numtaxamax" => 5, "numtaxamin"=> 5, "numblocksmax" => "all" );
.Ve
.Sh "pruneUninformativeTaxa"
.IX Subsection "pruneUninformativeTaxa"
Somewhat missnamed, removes taxa with less than \-cutoff % (0.00 \- 1.00 data) from \f(CW$self\fR.
.PP
Must pass a matrix object as \-mx
.Sh "collapse"
.IX Subsection "collapse"
Collapses slices based on adjoining bracketed or unbracketed blocks.  Returns a \s-1HOH\s0 that looks like this:
.PP
.Vb 24
\&        '0' => {
\&                         'type' => 0,
\&                         'slice' => bless( {
\&                                                                 'Blocks' => {
\&                                                                                           '0' => undef
\&                                                                                         },
\&                                                                 'VERSION' => '0.01',
\&                                                                 'Taxa' => {},
\&                                                                 'Kind' => ''
\&                                                           }, 'slice' )
\&                   },
\&        '1' => {
\&                         'type' => 1,
\&                         'slice' => bless( {
\&                                                                 'Blocks' => {
\&                                                                                           '1' => undef,
\&                                                                                           '2' => undef
\&                                                                                         },
\&                                                                 'VERSION' => '0.01',
\&                                                                 'Taxa' => {},
\&                                                                 'Kind' => ''
\&                                                           }, 'slice' )
\&                   }
\&                   ...
.Ve
.Sh "describeCollapsed"
.IX Subsection "describeCollapsed"
Not really an object method, but called as such for now.  Describes the breakdown of the results of \f(CW$s\fR\->collapse 
.Sh "prune"
.IX Subsection "prune"
Removes bracketed or unbracketed blocks from the slice.  
.PP
.Vb 1
\&        -modes => < [bracketed] | unbracketed >
.Ve
.Sh "containsBlk"
.IX Subsection "containsBlk"
Returns true if it contains a block at the passed index (not block object)
.Sh "unexcludedBlkStart"
.IX Subsection "unexcludedBlkStart"
The following 4 methods are hacks to take a matrix, and a block index and return a start/end value.  See structure\->nucPairs for usage.
.PP
Requires:
	\-mx
	\-blk_index
