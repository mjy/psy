package Psy;

use warnings;
use strict;
use Data::Dumper;
use Carp;


use Exporter;
use vars qw(@ISA $VERSION @EXPORT_OK $PSY_BASE_DIR);
@ISA = qw(Exporter);

# some library fu
BEGIN {
	use FindBin qw($Bin);		# sets $Bin to the root directory
	our $PSY_BASE_DIR = $Bin;	# this directory is the directory the script is executed from??
 	our $debug;

	#	eval { require Psy::Config; }; # won't fail if not there
	#	if ( ! $@ ) { # $@ 
			#		push @INC, "Templates";
			#	print @INC;
		}
	# if Psy::Config is not created (i.e. Psy not formally installed) then add the Templates directory to the path
	
	#}

use Psy::Matrix::Matrix;
use Psy::Dna::Iupac;
use Psy::Output::Output;
use File::Spec;

=head1 NAME

Psy::Psy

=head1 VERSION

Version 0.01

=cut

$VERSION = '0.01';

=head1 SYNOPSIS

A wrapper for various purposes.  Should contain base functions that are inherited by all modules (versions etc.).
 
Example usage: 
	my %params = ( 
		'-matrix_file' => 'matrix',
		'-matrix_label' => 'my_label',
		'-helix_index' => 'stem_index',
		'-path' => 'some/path/',
		'-number_terminals' => 8,  
		'-project_name' => 'test'
	);

	my $foo = Psy->new(%params);


=head1 EXPORT

=cut

# @EXPORT_OK = qw(new generatedByHeader version rootpath projectname starttime $ROOT_DIR $PSY_BASE_DIR $PSY_ROOT_DIR);

=head1 OBJECT

=cut

sub new {
	my $type = shift;
	my %params = @_;	
  	my $self = {};
	
	bless $self, $type;
	$self->_init(%params);

    return $self;                 
}

sub _init {
	my $self= shift;
	my %params = @_;
	
	print "\n";
	
	#srand();
	
	%params = $self->_verify(%params);

	# print "params after verify: ", %params, "\n";
	
	$self->{_matrix_accession} = 0;
	$self->{_structure_accession} = 0;
	
	$self->{matricies} = {}; # named hash pointing to matrices	
	$self->version($VERSION);
	$self->rootpath();
	$self->starttime();
	
	$self->projectname($params{'-project_name'});

	my $working_matrix;
	
	if (defined $params{'-matrix_file'}) {
	   	print "_init matricies from Psy.pm\n";	
		$working_matrix = $self->_init_matricies(%params)
	};

	if ($params{'-helix_index'}) {
		 $self->mx( '-matrix_label' => $working_matrix)->{structures}->{"original"}->_load(%params);  
	};

	if (($params{'-matrix_file'}) and ($params{'-helix_index'})) { 
			 $self->mx('-matrix_label' => $working_matrix)->{structures}->{"original"}->_build_helices(
																							'-mx' => $self->mx( '-matrix_label' => $working_matrix ),
																							%params
																						)
	}

	return 1;
}


=head2 _verify

internal, does nothing thus far

=cut

sub _verify {
	my $self=shift;
	my %params = @_;
		#	foreach my $p (keys %params) { # check Psy parameters here
		#			print "$p\n";
		#		if ($p eq '-datapath') {
		#	}
		#}

	$params{'-project_name'} = 'my_project' if not defined $params{'-projectname'};
	
	return %params;
}


=head2 mx

a matrix accessor

=cut

sub mx {
	my $self=shift;

	if (@_) {

		# debug
		# print "MX PARAMS: ";
		# print join " ", @_;
		# print "\n";
		
		my %params = @_;
		if ($params{'-matrix_label'}) {		 
			return ( $self->{matricies}->{$params{'-matrix_label'}} )
		}

		# run a test on the mx object here
	}
	else {
		croak "no matrix requested"
	}	
	0
#	return {shift $self->{matricies} } # no matrix requested, return a reference to the last in stack
}

sub version {
	my $self = shift;
	if (@_) { $self->{VERSION} = shift; }
	return $self->{VERSION};
}

sub rootpath {
	my $self = shift;
	if (not defined $self->{ROOTPATH}) { use FindBin qw($Bin); $self->{ROOTPATH} = $Bin; }
	return $self->{ROOTPATH};
}

sub starttime {
	my $self = shift;
	if (not defined $self->{STARTTIME}) { $self->{STARTTIME} = localtime($^T); }
	return $self->{STARTTIME};
}

sub projectname {
	my $self = shift;
	if (@_) { $self->{PROJECTNAME} = shift; }
	return $self->{PROJECTNAME};
}

sub generatedByHeader {
	my $self = shift;
	my $h = "generated by Psy ver. ", $self->version, " on ", $self->starttime, " for project ", $self->projectname;
}

sub _init_matricies {
	my $self=shift;
	my %params = @_;
	my $label;

 	print "incoming label:",	$params{'-matrix_label'} , "\n";; 
	
	if (defined	$params{'-matrix_label'}) {
		$label = $params{'-matrix_label'}
	}	
	else {
		$label = "matrix_".$self->{_matrix_accession}; 
	}

	$self->{matricies}->{$label} = matrix->new(%params);
	
	$self->{_matrix_accession}++;

	# handles pointers to hashes as such -> single data path-> appended to all; hash -> one to many, no path, array - many

	print "\ninitialized matrix: $label\n";

	return ($label); # necessary!
}

sub _init_helices {
	my $self=shift;
	my %params = @_;

	# required:
	# -mx => matrix object
	
	# optional:
	# -helix_slice => a slice object
	
	croak "no matrix" if not $params{'-matrix_label'};
	my $mx =  $self->mx(%params);
	
	my $slice;

	if (defined $params{'-helix_slice'}) { 
	   	$slice = $params{'-helix_slice'} 
	} 
   	else {
		$slice = $mx->orig_slice()
	};

   	print "slice:\n", $slice->decribe_coded();
	print "\n";
	
	$self->mx(%params)->{structures}->{"original"}->_build_helices(
																	'-mx' => $self->mx(%params),
																	'-helix_slice' => $slice
																);
}

=head1 AUTHOR

'Matt, C<< <m{j}yoder@{tee}[aye](em)(you).domain4unis> >>

=head1 BUGS

Please report any bugs or feature requests to
C<bug-psy-psy@rt.cpan.org>, or through the web interface at
L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Psy>.
I will be notified, and then you'll automatically be notified of progress on
your bug as I make changes.

=head1 ACKNOWLEDGEMENTS

=head1 COPYRIGHT & LICENSE

Copyright 2005 'Matt, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

1; # End of Psy::Psy
